
### try-catch
ในการเขียนโค้ดจริง ปัญหาไม่ได้เกิดจากเราผิดเสมอไป แต่เกิดจาก ปัจจัยภายนอก ที่เราควบคุมไม่ได้
- External Server พัง: เรียก API นอกแล้วมัน Return 500 หรือเน็ตเน่า
- Database ล่ม: เชื่อมต่อฐานข้อมูลไม่ได้ในเสี้ยววินาทีนัน
- Data ผิดรูป: JSON ที่ส่งกลับมาไม่อยู่ใน Format ที่คาดหวัง (เช่น พยายามเข้าถึง data.user.id แต่ user เป็น undefined)

หากไม่มีการดับจับจะเกิดอาการ Process Crash (server ดับ)

การสร้างขอบเขตความเสียหาย (Error Boundary) -> try/carch เข้ามาจัดการวงจรของ Error 
- Stop Propagation: หยุด Error ไม่ให้ลามไปถึงระดับ System จนสั่งปิด Process (Server ไม่ตาย)
- Graceful Degradation: เปลี่ยนจาก "App พัง" ให้กลายเป็น "ส่งสถานะความผิดพลาด" (เช่น ส่ง 400 Bad Request หรือ 500 Internal Server Error กลับไป)
- System Awareness: ช่วยให้เรารู้ว่าพังที่ไหน ผ่านการทำ console.error หรือส่ง Log ไปยังระบบ Monitoring (เช่น Sentry) โดยที่โปรแกรมยังรันต่อได้


สรุป

ปัญหา: โค้ดหยุดทำงานทันทีเมื่อเจอสิ่งเหนือความคาดหมาย (Runtime Error)

แก้ไข: บีบให้ความพังอยู่เฉพาะจุด (Isolate Error) และรักษาระบบส่วนรวมให้ทำงานต่อได้

### throw
ปัญหาใหญ่ของการเขียนโค้ดคือ "การปล่อยให้โปรแกรมรันต่อไปทั้งที่ข้อมูลผิด"
ตัวอย่าง คุณกำลังทำระบบถอนเงิน ระบบเช็คแล้วว่า "เงินในบัญชีไม่พอ" แต่ถ้าคุณไม่สั่งหยุด โค้ดบรรทัดถัดไปก็จะไปหักเงิน หรือสั่งจ่ายเงินออกไปจริงๆ

หากใช้แค่ if/else ปกติในฟังก์ชันซ้อนฟังก์ชัน คุณต้องเขียน return ส่งค่ากลับไปเรื่อยๆ เพื่อบอกตัวแม่ว่า "มีปัญหานะ" ซึ่งทำให้โค้ดรกและซับซ้อน (Spaghetti Code)

เกิดข้อมูลเพี้ยนในระบบ (Data Corruption) หรือระบบทำงานผิดพลาดโดยไม่มีการแจ้งเตือนที่ชัดเจน

throw คือการสร้าง "สัญญาณเตือนภัย" เพื่อหยุดการทำงานในปัจจุบันและดีดตัวเองออกจากฟังก์ชันนั้นทันที
- สั่งให้โค้ดหยุดรันบรรทัดถัดไปทันที เพื่อป้องกันความเสียหาย
-  ส่งวัตถุ Error (Error Object) ที่ระบุเหตุผลได้ชัดเจนว่า "พังเพราะอะไร" ออกไปพร้อมกัน
- บีบให้ระบบกระโดดไปที่บล็อก catch ที่ใกล้ที่สุด ทำให้เราจัดการ Error ได้ในที่เดียว ไม่ต้องเขียน if เช็คทุกบรรทัด

### express crash
ลองนึกภาพว่าคุณเพิ่งปล่อยฟีเจอร์ใหม่ขึ้น Production ในคืนวันศุกร์ ทุกอย่างดูปกติดีจนกระทั่ง Traffic เริ่มถาโถมเข้ามา อยู่ดีๆ Server ของคุณก็ "นิ่ง" ไปเฉยๆ ไม่ตอบสนอง หรือหนักกว่านั้นคือ Process ตาย (Crash) ทิ้งให้ User เจอหน้าจอขาวว่างเปล่า

การป้องกัน Express Crash คือการ "กักบริเวณ Error" ไม่ให้มันลามไปถึงตัว Process หลักของ Node.js จนทำให้ Service ล่มทั้งระบบ

## unhandled rejection
คือวินัยในการเขียนโค้ด การแก้ไขที่ดีที่สุดไม่ใช่แค่การใส่ catch เพื่อให้ Error หายไป แต่คือการ "วางแผนว่าถ้าพังแล้วจะให้ระบบไปทางไหนต่อ" เพื่อให้แอปพลิเคชันของคุณมีความเป็นมืออาชีพและทนทาน (Resilient)

## global error handler

ลองจินตนาการดูครับ: คุณเพิ่งปล่อยฟีเจอร์ใหม่ให้ลูกค้าใช้งานอย่างราบรื่น แต่ผ่านไป 5 นาที ระบบกลับล่ม (Crash) เพียงเพราะมีผู้ใช้คนหนึ่งใส่ค่าว่างในช่องที่ไม่ได้คาดคิดไว้

แทนที่โปรแกรมจะบอกผู้ใช้อย่างสุภาพว่า "เกิดข้อผิดพลาด" มันกลับพ่น Stack Trace ยาวเหยียดออกมา หรือที่แย่กว่านั้นคือ "หน้าขาว" (White Screen of Death) ที่ทำให้ผู้ใช้ไปต่อไม่ได้ และคุณเองก็ไม่รู้เลยว่ามันพังที่บรรทัดไหนจนกว่าลูกค้าจะโทรมาด่า

นี่คือเหตุผลที่ Global Error Handler ไม่ใช่แค่ฟีเจอร์เสริม แต่เป็น "ตาข่ายนิรภัย" ชั้นสุดท้ายของ Code ที่มีคุณภาพครับ