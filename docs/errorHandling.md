
### try-catch
ในการเขียนโค้ดจริง ปัญหาไม่ได้เกิดจากเราผิดเสมอไป แต่เกิดจาก ปัจจัยภายนอก ที่เราควบคุมไม่ได้
- External Server พัง: เรียก API นอกแล้วมัน Return 500 หรือเน็ตเน่า
- Database ล่ม: เชื่อมต่อฐานข้อมูลไม่ได้ในเสี้ยววินาทีนัน
- Data ผิดรูป: JSON ที่ส่งกลับมาไม่อยู่ใน Format ที่คาดหวัง (เช่น พยายามเข้าถึง data.user.id แต่ user เป็น undefined)

หากไม่มีการดับจับจะเกิดอาการ Process Crash (server ดับ)

การสร้างขอบเขตความเสียหาย (Error Boundary) -> try/carch เข้ามาจัดการวงจรของ Error 
- Stop Propagation: หยุด Error ไม่ให้ลามไปถึงระดับ System จนสั่งปิด Process (Server ไม่ตาย)
- Graceful Degradation: เปลี่ยนจาก "App พัง" ให้กลายเป็น "ส่งสถานะความผิดพลาด" (เช่น ส่ง 400 Bad Request หรือ 500 Internal Server Error กลับไป)
- System Awareness: ช่วยให้เรารู้ว่าพังที่ไหน ผ่านการทำ console.error หรือส่ง Log ไปยังระบบ Monitoring (เช่น Sentry) โดยที่โปรแกรมยังรันต่อได้


สรุป

ปัญหา: โค้ดหยุดทำงานทันทีเมื่อเจอสิ่งเหนือความคาดหมาย (Runtime Error)

แก้ไข: บีบให้ความพังอยู่เฉพาะจุด (Isolate Error) และรักษาระบบส่วนรวมให้ทำงานต่อได้

### throw
ปัญหาใหญ่ของการเขียนโค้ดคือ "การปล่อยให้โปรแกรมรันต่อไปทั้งที่ข้อมูลผิด"
ตัวอย่าง คุณกำลังทำระบบถอนเงิน ระบบเช็คแล้วว่า "เงินในบัญชีไม่พอ" แต่ถ้าคุณไม่สั่งหยุด โค้ดบรรทัดถัดไปก็จะไปหักเงิน หรือสั่งจ่ายเงินออกไปจริงๆ

หากใช้แค่ if/else ปกติในฟังก์ชันซ้อนฟังก์ชัน คุณต้องเขียน return ส่งค่ากลับไปเรื่อยๆ เพื่อบอกตัวแม่ว่า "มีปัญหานะ" ซึ่งทำให้โค้ดรกและซับซ้อน (Spaghetti Code)

เกิดข้อมูลเพี้ยนในระบบ (Data Corruption) หรือระบบทำงานผิดพลาดโดยไม่มีการแจ้งเตือนที่ชัดเจน

throw คือการสร้าง "สัญญาณเตือนภัย" เพื่อหยุดการทำงานในปัจจุบันและดีดตัวเองออกจากฟังก์ชันนั้นทันที
- สั่งให้โค้ดหยุดรันบรรทัดถัดไปทันที เพื่อป้องกันความเสียหาย
-  ส่งวัตถุ Error (Error Object) ที่ระบุเหตุผลได้ชัดเจนว่า "พังเพราะอะไร" ออกไปพร้อมกัน
- บีบให้ระบบกระโดดไปที่บล็อก catch ที่ใกล้ที่สุด ทำให้เราจัดการ Error ได้ในที่เดียว ไม่ต้องเขียน if เช็คทุกบรรทัด

### express crash

## unhandled rejection

## global error handler
